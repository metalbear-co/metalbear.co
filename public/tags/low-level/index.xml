<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Low-Level on </title>
    <link>http://localhost:54350/tags/low-level/</link>
    <description>Recent content in Low-Level on </description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Tue, 24 Jan 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:54350/tags/low-level/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Fun with macOS&#39;s SIP</title>
      <link>http://localhost:54350/blog/fun-with-macoss-sip/</link>
      <pubDate>Tue, 24 Jan 2023 00:00:00 +0000</pubDate>
      <guid>http://localhost:54350/blog/fun-with-macoss-sip/</guid>
      <description>&lt;p&gt;While developing mirrord, which heavily relies on injecting itself into other people&amp;rsquo;s binaries, we ran into some challenges posed by macOS’s SIP (System Integrity Protection). This post details how we ultimately overcame these challenges, and we hope it can be of help to other people hoping to learn about SIP, as we&amp;rsquo;ve learned the hard way that there&amp;rsquo;s very little written about this subject on the internet.&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-is-mirrord&#34;&gt;What is mirrord? &lt;a href=&#34;#what-is-mirrord&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://mirrord.dev&#34;   target=&#34;_blank&#34; &gt;&#xA;    mirrord&#xA;  &lt;/a&gt;&#xA;   lets you run a local process in the context of a cloud service, which means we can test our code on our staging cluster without actually deploying it there. This leads to shorter feedback loops (you don’t have to wait on long CI processes to test your code in staging conditions) and a more stable staging environment (since untested services aren’t being deployed there). There is a detailed overview of mirrord in &lt;a href=&#34;https://metalbear.co/blog/mirrord-3.0-is-out/&#34;   target=&#34;_blank&#34; &gt;&#xA;    this&#xA;  &lt;/a&gt;&#xA;   blog post.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Hooking Go from Rust - Hitchhiker’s Guide to the Go-laxy</title>
      <link>http://localhost:54350/blog/hooking-go-from-rust-hitchhikers-guide-to-the-go-laxy/</link>
      <pubDate>Wed, 17 Aug 2022 15:00:00 +0000</pubDate>
      <guid>http://localhost:54350/blog/hooking-go-from-rust-hitchhikers-guide-to-the-go-laxy/</guid>
      <description>&lt;p&gt;Most mainstream programming languages strive to fit into a few common standards, to increase interoperability and decrease adoption friction. Golang isn’t one of those (there &lt;a href=&#34;https://spectralops.io/blog/rust-vs-go-why-not-use-both/&#34;   target=&#34;_blank&#34; &gt;&#xA;    are&#xA;  &lt;/a&gt;&#xA;   &lt;a href=&#34;https://words.filippo.io/rustgo/&#34;   target=&#34;_blank&#34; &gt;&#xA;    several&#xA;  &lt;/a&gt;&#xA;   &lt;a href=&#34;https://fasterthanli.me/articles/lies-we-tell-ourselves-to-keep-using-golang&#34;   target=&#34;_blank&#34; &gt;&#xA;    articles&#xA;  &lt;/a&gt;&#xA;   on the subject). In this blog post we’ll demonstrate how to overcome Go’s isolationist design and integrate with it from another language (in our case Rust).&lt;/p&gt;&#xA;&lt;p&gt;Why do we need to interop with Go? mirrord&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; works by &lt;a href=&#34;https://metalbear.co/blog/mirrord-internals-hooking-libc-functions-in-rust-and-fixing-bugs/&#34;   target=&#34;_blank&#34; &gt;&#xA;    hooking system calls to the operating systems&#xA;  &lt;/a&gt;&#xA;   and applying logic that decides whether to execute locally or remotely. To do that, mirrord side-loads (using &lt;code&gt;LD_PRELOAD&lt;/code&gt;) into the process, then hooks relevant functions.&#xA;To cover most common scenarios, mirrord hooks libc functions and this works for most common languages (Python, Go on macOS, Rust, Node to name a few) as they all rely on libc.&lt;/p&gt;</description>
    </item>
    <item>
      <title>mirrord internals - hooking libc functions in Rust and fixing bugs</title>
      <link>http://localhost:54350/blog/mirrord-internals-hooking-libc-functions-in-rust-and-fixing-bugs/</link>
      <pubDate>Mon, 04 Jul 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:54350/blog/mirrord-internals-hooking-libc-functions-in-rust-and-fixing-bugs/</guid>
      <description>&lt;p&gt;&amp;ldquo;Is mirrord some kind of &lt;a href=&#34;https://man7.org/linux/man-pages/man2/ptrace.2.html&#34;   target=&#34;_blank&#34; &gt;&#xA;    ptrace&#xA;  &lt;/a&gt;&#xA;   magic?”, that’s what I exactly thought when I was introduced to this idea of “mirroring traffic”. To my surprise, the idea and design behind mirrord are based on simple concepts implemented in a novel way! This is what I want to discuss in this blog post along with my experience as a Junior Engineer learning how to tackle bugs working on this badass project.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Carcinisation of mirrord (or: why we use Rust)</title>
      <link>http://localhost:54350/blog/carcinisation-of-mirrord-or-why-we-use-rust/</link>
      <pubDate>Tue, 14 Jun 2022 00:00:00 +0000</pubDate>
      <guid>http://localhost:54350/blog/carcinisation-of-mirrord-or-why-we-use-rust/</guid>
      <description>&lt;p&gt;&lt;figure class=&#34;center&#34;&gt;&lt;img src=&#34;http://localhost:54350/blog/carcinisation-of-mirrord-or-why-we-use-rust/rustacean-flat-happy.svg&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;strong&gt;Carcinisation&lt;/strong&gt; (or &lt;strong&gt;carcinization&lt;/strong&gt;) is an example of &lt;a href=&#34;https://en.wikipedia.org/wiki/Convergent_evolution&#34;   target=&#34;_blank&#34; &gt;&#xA;    convergent evolution&#xA;  &lt;/a&gt;&#xA;   in which a &lt;a href=&#34;https://en.wikipedia.org/wiki/Crustacean&#34;   target=&#34;_blank&#34; &gt;&#xA;    crustacean&#xA;  &lt;/a&gt;&#xA;   &lt;a href=&#34;https://en.wikipedia.org/wiki/Evolution&#34;   target=&#34;_blank&#34; &gt;&#xA;    evolves&#xA;  &lt;/a&gt;&#xA;   into a &lt;a href=&#34;https://en.wikipedia.org/wiki/Crab&#34;   target=&#34;_blank&#34; &gt;&#xA;    crab&#xA;  &lt;/a&gt;&#xA;  -like form from a non-crab-like form. (source: &lt;a href=&#34;https://en.wikipedia.org/wiki/Carcinisation&#34;   target=&#34;_blank&#34; &gt;&#xA;    Wikipedia&#xA;  &lt;/a&gt;&#xA;  ).&lt;/p&gt;&#xA;&lt;p&gt;A classic example of carcinisation is MetalBear&amp;rsquo;s mirrord project, where several different components converged on Rust as their main language. In this post, we&amp;rsquo;ll detail their different evolutionary paths and explain why they ended up being written in Rust.&lt;/p&gt;&#xA;&lt;h1 id=&#34;first-of-all-what-is-mirrord&#34;&gt;First of all, what is mirrord? &lt;a href=&#34;#first-of-all-what-is-mirrord&#34; class=&#34;anchor&#34; aria-hidden=&#34;true&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;mirrord is an open-source tool that lets developers run local processes in the context of their cloud environment. It is meant to provide the benefits of running your service in a cloud environment (e.g. staging) without going through the hassle of actually deploying it there, and without disrupting the environment by deploying untested code.&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
